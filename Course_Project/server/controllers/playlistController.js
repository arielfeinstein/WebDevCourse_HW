/*
Playlist JSON structure (file: data/playlists.json)

Overall file shape:
An array of playlist objects
[
    {
        "id": "string",      // unique playlist id (string)
        "name": "string",    // playlist name
        "songs": [            // array of song entry objects (may be empty)
            {
                "entryId": "string",  // unique id for this specific song entry
                "youtubeId": "string" // YouTube video id (e.g., 'dQw4w9WgXcQ')
            }
        ]
    },
    ...
]

Notes:
- `id` and `entryId` are generated by the controller's `generateId()` function.
- `songs` may be omitted or an empty array when a playlist has no songs.
- `entryId` allows the same `youtubeId` to be added multiple times and removed individually.
*/

const fs = require('fs');
const path = require('path');
const { readUsersFromJson, writeUsersToJson } = require('../utils/userHelpers');
const youtubeService = require('../services/youtubeDataService');

const DATA_FILE = path.join(__dirname, '../data/playlists.json');

// Helper: Read playlists from JSON file
function readPlaylistsFromJson() {
    try {
        const data = fs.readFileSync(DATA_FILE, 'utf8');
        return JSON.parse(data);
    } catch (err) {
        // If file doesn't exist or is invalid, return empty array
        return [];
    }
}

// Helper: Write playlists to JSON file
function writePlaylistsToJson(playlists) {
    // Ensure parent directory exists (create recursively if needed)
    const dir = path.dirname(DATA_FILE);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(DATA_FILE, JSON.stringify(playlists, null, 2), 'utf8');
}

// Helper: Generate a unique ID
function generateId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
}

// GET /playlists (render playlists page with data)
exports.renderPlaylistsPage = async (req, res) => {
    const playlistId = req.query.id;
    let playlists = [];
    let selectedPlaylist = null;
    let videosWithDetails = [];
    let error = null;

    try {
        // Get all playlists
        playlists = readPlaylistsFromJson();

        // If a specific playlist is selected, fetch video details
        if (playlistId) {
            selectedPlaylist = playlists.find(p => p.id === playlistId);
            
            if (selectedPlaylist && selectedPlaylist.songs && selectedPlaylist.songs.length > 0) {
                const youtubeIds = selectedPlaylist.songs.map(song => song.youtubeId);
                const videoDetails = await youtubeService.getCompleteVideoInfo(youtubeIds);
                
                // Merge with song entries (to preserve entryId and rating)
                videosWithDetails = selectedPlaylist.songs.map(song => {
                    const details = videoDetails.find(v => v.videoId === song.youtubeId);
                    return {
                        entryId: song.entryId,
                        youtubeId: song.youtubeId,
                        rating: song.rating || null,
                        ...details
                    };
                });
            }
        }
    } catch (err) {
        console.error('Error loading playlists:', err);
        error = err.message || 'An error occurred while loading playlists';
    }

    res.render('playlists/playlists', {
        playlists,
        selectedPlaylist,
        videos: videosWithDetails,
        error
    });
};

// GET /api/playlists
exports.getPlaylists = (req, res) => {
    const playlists = readPlaylistsFromJson();
    res.status(200).json(playlists);
};

// POST /api/playlists
exports.createPlaylist = (req, res) => {
    const { name, username } = req.body;

    // Check playlist name is not empty
    if (!name || typeof name !== 'string' || name.trim() === '') {
        return res.status(400).json({ error: 'Playlist name is required and cannot be empty' });
    }

    // Check username is provided
    if (!username || typeof username !== 'string' || username.trim() === '') {
        return res.status(400).json({ error: 'Username is required' });
    }

    // Verify user exists
    const users = readUsersFromJson();
    const userIndex = users.findIndex(u => u.username === username);
    if (userIndex === -1) {
        return res.status(404).json({ error: 'User not found' });
    }

    const playlists = readPlaylistsFromJson();
    
    const newPlaylist = {
        id: generateId(),
        name: name.trim(),
        songs: [] // List of song objects: { entryId, youtubeId }
    };

    playlists.push(newPlaylist);
    writePlaylistsToJson(playlists);

    // Add playlist ID to user's playlistIDs
    if (!users[userIndex].playlistIDs) {
        users[userIndex].playlistIDs = [];
    }
    users[userIndex].playlistIDs.push(newPlaylist.id);
    writeUsersToJson(users);

    res.status(201).json(newPlaylist);
};

// DELETE /api/playlists/:id
exports.deletePlaylist = (req, res) => {
    const { id } = req.params;
    let playlists = readPlaylistsFromJson();

    const initialLength = playlists.length;
    playlists = playlists.filter(p => p.id !== id);

    if (playlists.length === initialLength) {
        return res.status(404).json({ error: 'Playlist not found' });
    }

    writePlaylistsToJson(playlists);

    // Remove playlist ID from user's playlistIDs array
    const users = readUsersFromJson();
    const userIndex = users.findIndex(u => u.playlistIDs && u.playlistIDs.includes(id));
    if (userIndex !== -1) {
        users[userIndex].playlistIDs = users[userIndex].playlistIDs.filter(pid => pid !== id);
        writeUsersToJson(users);
    }

    res.status(200).json({ message: 'Playlist deleted successfully' });
};

// PUT /api/playlists/:id
exports.updatePlaylist = (req, res) => {
    const { id } = req.params;
    const { name } = req.body;

    if (!name || typeof name !== 'string' || name.trim() === '') {
        return res.status(400).json({ error: 'Playlist name is required and cannot be empty' });
    }

    const playlists = readPlaylistsFromJson();
    const playlistIndex = playlists.findIndex(p => p.id === id);

    if (playlistIndex === -1) {
        return res.status(404).json({ error: 'Playlist not found' });
    }

    playlists[playlistIndex].name = name.trim();
    writePlaylistsToJson(playlists);

    res.status(200).json(playlists[playlistIndex]);
};

// POST /api/playlists/:id/songs
exports.addSongToPlaylist = (req, res) => {
    const { id } = req.params;
    const { youtubeId } = req.body;

    if (!youtubeId || typeof youtubeId !== 'string' || youtubeId.trim() === '') {
        return res.status(400).json({ error: 'youtubeId is required' });
    }

    const playlists = readPlaylistsFromJson();
    const playlist = playlists.find(p => p.id === id);

    if (!playlist) {
        return res.status(404).json({ error: 'Playlist not found' });
    }
    
    // We use an entryId to uniquely identify this specific addition of the song.
    // This allows the same song to be added multiple times and removed individually.
    const newSongEntry = {
        entryId: generateId(),
        youtubeId: youtubeId
    };

    // Ensure 'songs' array exists
    if (!playlist.songs) {
        playlist.songs = [];
    }

    playlist.songs.push(newSongEntry);
    writePlaylistsToJson(playlists);

    res.status(200).json(playlist);
};

// DELETE /api/playlists/:id/songs/:songId
exports.removeSongFromPlaylist = (req, res) => {
    const { id, songId } = req.params; // songId here refers to the entryId

    const playlists = readPlaylistsFromJson();
    const playlist = playlists.find(p => p.id === id);

    if (!playlist) {
        return res.status(404).json({ error: 'Playlist not found' });
    }

    if (!playlist.songs) {
        return res.status(404).json({ error: 'Song not found in playlist' });
    }

    const initialSongsLength = playlist.songs.length;
    // Filter by entryId
    playlist.songs = playlist.songs.filter(song => song.entryId !== songId);

    if (playlist.songs.length === initialSongsLength) {
         return res.status(404).json({ error: 'Song not found in playlist' });
    }

    writePlaylistsToJson(playlists);
    res.status(200).json(playlist);
};

// GET /api/playlists/users/:username
exports.getPlaylistsForUser = (req, res) => {
    const { username } = req.params;

    // Verify user exists
    const users = readUsersFromJson();
    const user = users.find(u => u.username === username);
    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }

    const playlistIDs = user.playlistIDs || [];
    const playlists = readPlaylistsFromJson();
    const userPlaylists = playlists.filter(p => playlistIDs.includes(p.id));

    res.status(200).json(userPlaylists);
};

// PUT /api/playlists/:id/songs/:songId
exports.updateSongInPlaylist = (req, res) => {
    const { id, songId } = req.params;
    const { rating } = req.body;

    if (rating === undefined) {
        return res.status(400).json({ error: 'Rating is required' });
    }

    const playlists = readPlaylistsFromJson();
    const playlist = playlists.find(p => p.id === id);

    if (!playlist) {
        return res.status(404).json({ error: 'Playlist not found' });
    }

    if (!playlist.songs) {
        return res.status(404).json({ error: 'Song not found in playlist' });
    }

    const song = playlist.songs.find(s => s.entryId === songId);
    if (!song) {
        return res.status(404).json({ error: 'Song not found in playlist' });
    }

    song.rating = rating;
    writePlaylistsToJson(playlists);

    res.status(200).json(song);
};
